// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffetool.proto

#ifndef PROTOBUF_caffetool_2eproto__INCLUDED
#define PROTOBUF_caffetool_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace caffe_neural {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_caffetool_2eproto();
void protobuf_AssignDesc_caffetool_2eproto();
void protobuf_ShutdownFile_caffetool_2eproto();

class ToolParam;
class BenchmarkParam;
class TrainParam;
class ProcessParam;
class FilterOutputParam;
class InputParam;
class OutputParam;
class PreprocessorParam;
class PrepCropParam;
class PrepBlurParam;
class PrepDeformParam;
class PrepClaheParam;
class PrepHistEqParam;

// ===================================================================

class ToolParam : public ::google::protobuf::Message {
 public:
  ToolParam();
  virtual ~ToolParam();

  ToolParam(const ToolParam& from);

  inline ToolParam& operator=(const ToolParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ToolParam& default_instance();

  void Swap(ToolParam* other);

  // implements Message ----------------------------------------------

  ToolParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ToolParam& from);
  void MergeFrom(const ToolParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .caffe_neural.TrainParam train = 1;
  inline int train_size() const;
  inline void clear_train();
  static const int kTrainFieldNumber = 1;
  inline const ::caffe_neural::TrainParam& train(int index) const;
  inline ::caffe_neural::TrainParam* mutable_train(int index);
  inline ::caffe_neural::TrainParam* add_train();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe_neural::TrainParam >&
      train() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe_neural::TrainParam >*
      mutable_train();

  // repeated .caffe_neural.ProcessParam process = 2;
  inline int process_size() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 2;
  inline const ::caffe_neural::ProcessParam& process(int index) const;
  inline ::caffe_neural::ProcessParam* mutable_process(int index);
  inline ::caffe_neural::ProcessParam* add_process();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe_neural::ProcessParam >&
      process() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe_neural::ProcessParam >*
      mutable_process();

  // repeated .caffe_neural.BenchmarkParam benchmark = 3;
  inline int benchmark_size() const;
  inline void clear_benchmark();
  static const int kBenchmarkFieldNumber = 3;
  inline const ::caffe_neural::BenchmarkParam& benchmark(int index) const;
  inline ::caffe_neural::BenchmarkParam* mutable_benchmark(int index);
  inline ::caffe_neural::BenchmarkParam* add_benchmark();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe_neural::BenchmarkParam >&
      benchmark() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe_neural::BenchmarkParam >*
      mutable_benchmark();

  // @@protoc_insertion_point(class_scope:caffe_neural.ToolParam)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::caffe_neural::TrainParam > train_;
  ::google::protobuf::RepeatedPtrField< ::caffe_neural::ProcessParam > process_;
  ::google::protobuf::RepeatedPtrField< ::caffe_neural::BenchmarkParam > benchmark_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static ToolParam* default_instance_;
};
// -------------------------------------------------------------------

class BenchmarkParam : public ::google::protobuf::Message {
 public:
  BenchmarkParam();
  virtual ~BenchmarkParam();

  BenchmarkParam(const BenchmarkParam& from);

  inline BenchmarkParam& operator=(const BenchmarkParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BenchmarkParam& default_instance();

  void Swap(BenchmarkParam* other);

  // implements Message ----------------------------------------------

  BenchmarkParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BenchmarkParam& from);
  void MergeFrom(const BenchmarkParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 bench_runs = 1;
  inline bool has_bench_runs() const;
  inline void clear_bench_runs();
  static const int kBenchRunsFieldNumber = 1;
  inline ::google::protobuf::int32 bench_runs() const;
  inline void set_bench_runs(::google::protobuf::int32 value);

  // optional int32 warmup_runs = 2;
  inline bool has_warmup_runs() const;
  inline void clear_warmup_runs();
  static const int kWarmupRunsFieldNumber = 2;
  inline ::google::protobuf::int32 warmup_runs() const;
  inline void set_warmup_runs(::google::protobuf::int32 value);

  // optional string output = 3;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 3;
  inline const ::std::string& output() const;
  inline void set_output(const ::std::string& value);
  inline void set_output(const char* value);
  inline void set_output(const char* value, size_t size);
  inline ::std::string* mutable_output();
  inline ::std::string* release_output();
  inline void set_allocated_output(::std::string* output);

  // optional int32 train_index = 4;
  inline bool has_train_index() const;
  inline void clear_train_index();
  static const int kTrainIndexFieldNumber = 4;
  inline ::google::protobuf::int32 train_index() const;
  inline void set_train_index(::google::protobuf::int32 value);

  // optional int32 process_index = 5;
  inline bool has_process_index() const;
  inline void clear_process_index();
  static const int kProcessIndexFieldNumber = 5;
  inline ::google::protobuf::int32 process_index() const;
  inline void set_process_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe_neural.BenchmarkParam)
 private:
  inline void set_has_bench_runs();
  inline void clear_has_bench_runs();
  inline void set_has_warmup_runs();
  inline void clear_has_warmup_runs();
  inline void set_has_output();
  inline void clear_has_output();
  inline void set_has_train_index();
  inline void clear_has_train_index();
  inline void set_has_process_index();
  inline void clear_has_process_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 bench_runs_;
  ::google::protobuf::int32 warmup_runs_;
  ::std::string* output_;
  ::google::protobuf::int32 train_index_;
  ::google::protobuf::int32 process_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static BenchmarkParam* default_instance_;
};
// -------------------------------------------------------------------

class TrainParam : public ::google::protobuf::Message {
 public:
  TrainParam();
  virtual ~TrainParam();

  TrainParam(const TrainParam& from);

  inline TrainParam& operator=(const TrainParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrainParam& default_instance();

  void Swap(TrainParam* other);

  // implements Message ----------------------------------------------

  TrainParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrainParam& from);
  void MergeFrom(const TrainParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string solver = 1;
  inline bool has_solver() const;
  inline void clear_solver();
  static const int kSolverFieldNumber = 1;
  inline const ::std::string& solver() const;
  inline void set_solver(const ::std::string& value);
  inline void set_solver(const char* value);
  inline void set_solver(const char* value, size_t size);
  inline ::std::string* mutable_solver();
  inline ::std::string* release_solver();
  inline void set_allocated_solver(::std::string* solver);

  // optional string solverstate = 2;
  inline bool has_solverstate() const;
  inline void clear_solverstate();
  static const int kSolverstateFieldNumber = 2;
  inline const ::std::string& solverstate() const;
  inline void set_solverstate(const ::std::string& value);
  inline void set_solverstate(const char* value);
  inline void set_solverstate(const char* value, size_t size);
  inline ::std::string* mutable_solverstate();
  inline ::std::string* release_solverstate();
  inline void set_allocated_solverstate(::std::string* solverstate);

  // optional .caffe_neural.InputParam input = 3;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 3;
  inline const ::caffe_neural::InputParam& input() const;
  inline ::caffe_neural::InputParam* mutable_input();
  inline ::caffe_neural::InputParam* release_input();
  inline void set_allocated_input(::caffe_neural::InputParam* input);

  // @@protoc_insertion_point(class_scope:caffe_neural.TrainParam)
 private:
  inline void set_has_solver();
  inline void clear_has_solver();
  inline void set_has_solverstate();
  inline void clear_has_solverstate();
  inline void set_has_input();
  inline void clear_has_input();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* solver_;
  ::std::string* solverstate_;
  ::caffe_neural::InputParam* input_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static TrainParam* default_instance_;
};
// -------------------------------------------------------------------

class ProcessParam : public ::google::protobuf::Message {
 public:
  ProcessParam();
  virtual ~ProcessParam();

  ProcessParam(const ProcessParam& from);

  inline ProcessParam& operator=(const ProcessParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessParam& default_instance();

  void Swap(ProcessParam* other);

  // implements Message ----------------------------------------------

  ProcessParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessParam& from);
  void MergeFrom(const ProcessParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string process_net = 1;
  inline bool has_process_net() const;
  inline void clear_process_net();
  static const int kProcessNetFieldNumber = 1;
  inline const ::std::string& process_net() const;
  inline void set_process_net(const ::std::string& value);
  inline void set_process_net(const char* value);
  inline void set_process_net(const char* value, size_t size);
  inline ::std::string* mutable_process_net();
  inline ::std::string* release_process_net();
  inline void set_allocated_process_net(::std::string* process_net);

  // optional string caffemodel = 2;
  inline bool has_caffemodel() const;
  inline void clear_caffemodel();
  static const int kCaffemodelFieldNumber = 2;
  inline const ::std::string& caffemodel() const;
  inline void set_caffemodel(const ::std::string& value);
  inline void set_caffemodel(const char* value);
  inline void set_caffemodel(const char* value, size_t size);
  inline ::std::string* mutable_caffemodel();
  inline ::std::string* release_caffemodel();
  inline void set_allocated_caffemodel(::std::string* caffemodel);

  // optional .caffe_neural.InputParam input = 3;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 3;
  inline const ::caffe_neural::InputParam& input() const;
  inline ::caffe_neural::InputParam* mutable_input();
  inline ::caffe_neural::InputParam* release_input();
  inline void set_allocated_input(::caffe_neural::InputParam* input);

  // optional .caffe_neural.OutputParam output = 4;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 4;
  inline const ::caffe_neural::OutputParam& output() const;
  inline ::caffe_neural::OutputParam* mutable_output();
  inline ::caffe_neural::OutputParam* release_output();
  inline void set_allocated_output(::caffe_neural::OutputParam* output);

  // optional .caffe_neural.FilterOutputParam filter_output = 5;
  inline bool has_filter_output() const;
  inline void clear_filter_output();
  static const int kFilterOutputFieldNumber = 5;
  inline const ::caffe_neural::FilterOutputParam& filter_output() const;
  inline ::caffe_neural::FilterOutputParam* mutable_filter_output();
  inline ::caffe_neural::FilterOutputParam* release_filter_output();
  inline void set_allocated_filter_output(::caffe_neural::FilterOutputParam* filter_output);

  // @@protoc_insertion_point(class_scope:caffe_neural.ProcessParam)
 private:
  inline void set_has_process_net();
  inline void clear_has_process_net();
  inline void set_has_caffemodel();
  inline void clear_has_caffemodel();
  inline void set_has_input();
  inline void clear_has_input();
  inline void set_has_output();
  inline void clear_has_output();
  inline void set_has_filter_output();
  inline void clear_has_filter_output();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* process_net_;
  ::std::string* caffemodel_;
  ::caffe_neural::InputParam* input_;
  ::caffe_neural::OutputParam* output_;
  ::caffe_neural::FilterOutputParam* filter_output_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static ProcessParam* default_instance_;
};
// -------------------------------------------------------------------

class FilterOutputParam : public ::google::protobuf::Message {
 public:
  FilterOutputParam();
  virtual ~FilterOutputParam();

  FilterOutputParam(const FilterOutputParam& from);

  inline FilterOutputParam& operator=(const FilterOutputParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterOutputParam& default_instance();

  void Swap(FilterOutputParam* other);

  // implements Message ----------------------------------------------

  FilterOutputParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterOutputParam& from);
  void MergeFrom(const FilterOutputParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool output_filters = 1;
  inline bool has_output_filters() const;
  inline void clear_output_filters();
  static const int kOutputFiltersFieldNumber = 1;
  inline bool output_filters() const;
  inline void set_output_filters(bool value);

  // optional string output = 2;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 2;
  inline const ::std::string& output() const;
  inline void set_output(const ::std::string& value);
  inline void set_output(const char* value);
  inline void set_output(const char* value, size_t size);
  inline ::std::string* mutable_output();
  inline ::std::string* release_output();
  inline void set_allocated_output(::std::string* output);

  // @@protoc_insertion_point(class_scope:caffe_neural.FilterOutputParam)
 private:
  inline void set_has_output_filters();
  inline void clear_has_output_filters();
  inline void set_has_output();
  inline void clear_has_output();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* output_;
  bool output_filters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static FilterOutputParam* default_instance_;
};
// -------------------------------------------------------------------

class InputParam : public ::google::protobuf::Message {
 public:
  InputParam();
  virtual ~InputParam();

  InputParam(const InputParam& from);

  inline InputParam& operator=(const InputParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputParam& default_instance();

  void Swap(InputParam* other);

  // implements Message ----------------------------------------------

  InputParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputParam& from);
  void MergeFrom(const InputParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 padding_size = 1;
  inline bool has_padding_size() const;
  inline void clear_padding_size();
  static const int kPaddingSizeFieldNumber = 1;
  inline ::google::protobuf::int32 padding_size() const;
  inline void set_padding_size(::google::protobuf::int32 value);

  // optional int32 patch_size = 2;
  inline bool has_patch_size() const;
  inline void clear_patch_size();
  static const int kPatchSizeFieldNumber = 2;
  inline ::google::protobuf::int32 patch_size() const;
  inline void set_patch_size(::google::protobuf::int32 value);

  // optional int32 channels = 3;
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 3;
  inline ::google::protobuf::int32 channels() const;
  inline void set_channels(::google::protobuf::int32 value);

  // optional int32 labels = 4;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 4;
  inline ::google::protobuf::int32 labels() const;
  inline void set_labels(::google::protobuf::int32 value);

  // optional int32 batch_size = 5;
  inline bool has_batch_size() const;
  inline void clear_batch_size();
  static const int kBatchSizeFieldNumber = 5;
  inline ::google::protobuf::int32 batch_size() const;
  inline void set_batch_size(::google::protobuf::int32 value);

  // optional .caffe_neural.PreprocessorParam preprocessor = 6;
  inline bool has_preprocessor() const;
  inline void clear_preprocessor();
  static const int kPreprocessorFieldNumber = 6;
  inline const ::caffe_neural::PreprocessorParam& preprocessor() const;
  inline ::caffe_neural::PreprocessorParam* mutable_preprocessor();
  inline ::caffe_neural::PreprocessorParam* release_preprocessor();
  inline void set_allocated_preprocessor(::caffe_neural::PreprocessorParam* preprocessor);

  // optional string raw_images = 7;
  inline bool has_raw_images() const;
  inline void clear_raw_images();
  static const int kRawImagesFieldNumber = 7;
  inline const ::std::string& raw_images() const;
  inline void set_raw_images(const ::std::string& value);
  inline void set_raw_images(const char* value);
  inline void set_raw_images(const char* value, size_t size);
  inline ::std::string* mutable_raw_images();
  inline ::std::string* release_raw_images();
  inline void set_allocated_raw_images(::std::string* raw_images);

  // optional string label_images = 8;
  inline bool has_label_images() const;
  inline void clear_label_images();
  static const int kLabelImagesFieldNumber = 8;
  inline const ::std::string& label_images() const;
  inline void set_label_images(const ::std::string& value);
  inline void set_label_images(const char* value);
  inline void set_label_images(const char* value, size_t size);
  inline ::std::string* mutable_label_images();
  inline ::std::string* release_label_images();
  inline void set_allocated_label_images(::std::string* label_images);

  // @@protoc_insertion_point(class_scope:caffe_neural.InputParam)
 private:
  inline void set_has_padding_size();
  inline void clear_has_padding_size();
  inline void set_has_patch_size();
  inline void clear_has_patch_size();
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_labels();
  inline void clear_has_labels();
  inline void set_has_batch_size();
  inline void clear_has_batch_size();
  inline void set_has_preprocessor();
  inline void clear_has_preprocessor();
  inline void set_has_raw_images();
  inline void clear_has_raw_images();
  inline void set_has_label_images();
  inline void clear_has_label_images();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 padding_size_;
  ::google::protobuf::int32 patch_size_;
  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 labels_;
  ::caffe_neural::PreprocessorParam* preprocessor_;
  ::std::string* raw_images_;
  ::std::string* label_images_;
  ::google::protobuf::int32 batch_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static InputParam* default_instance_;
};
// -------------------------------------------------------------------

class OutputParam : public ::google::protobuf::Message {
 public:
  OutputParam();
  virtual ~OutputParam();

  OutputParam(const OutputParam& from);

  inline OutputParam& operator=(const OutputParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OutputParam& default_instance();

  void Swap(OutputParam* other);

  // implements Message ----------------------------------------------

  OutputParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OutputParam& from);
  void MergeFrom(const OutputParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string output = 1;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 1;
  inline const ::std::string& output() const;
  inline void set_output(const ::std::string& value);
  inline void set_output(const char* value);
  inline void set_output(const char* value, size_t size);
  inline ::std::string* mutable_output();
  inline ::std::string* release_output();
  inline void set_allocated_output(::std::string* output);

  // optional bool fp32_out = 2 [default = false];
  inline bool has_fp32_out() const;
  inline void clear_fp32_out();
  static const int kFp32OutFieldNumber = 2;
  inline bool fp32_out() const;
  inline void set_fp32_out(bool value);

  // optional bool out_all_labels = 3 [default = false];
  inline bool has_out_all_labels() const;
  inline void clear_out_all_labels();
  static const int kOutAllLabelsFieldNumber = 3;
  inline bool out_all_labels() const;
  inline void set_out_all_labels(bool value);

  // optional string format = 4 [default = "tif"];
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 4;
  inline const ::std::string& format() const;
  inline void set_format(const ::std::string& value);
  inline void set_format(const char* value);
  inline void set_format(const char* value, size_t size);
  inline ::std::string* mutable_format();
  inline ::std::string* release_format();
  inline void set_allocated_format(::std::string* format);

  // @@protoc_insertion_point(class_scope:caffe_neural.OutputParam)
 private:
  inline void set_has_output();
  inline void clear_has_output();
  inline void set_has_fp32_out();
  inline void clear_has_fp32_out();
  inline void set_has_out_all_labels();
  inline void clear_has_out_all_labels();
  inline void set_has_format();
  inline void clear_has_format();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* output_;
  ::std::string* format_;
  static ::std::string* _default_format_;
  bool fp32_out_;
  bool out_all_labels_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static OutputParam* default_instance_;
};
// -------------------------------------------------------------------

class PreprocessorParam : public ::google::protobuf::Message {
 public:
  PreprocessorParam();
  virtual ~PreprocessorParam();

  PreprocessorParam(const PreprocessorParam& from);

  inline PreprocessorParam& operator=(const PreprocessorParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreprocessorParam& default_instance();

  void Swap(PreprocessorParam* other);

  // implements Message ----------------------------------------------

  PreprocessorParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PreprocessorParam& from);
  void MergeFrom(const PreprocessorParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool normalization = 1 [default = true];
  inline bool has_normalization() const;
  inline void clear_normalization();
  static const int kNormalizationFieldNumber = 1;
  inline bool normalization() const;
  inline void set_normalization(bool value);

  // optional .caffe_neural.PrepCropParam crop = 2;
  inline bool has_crop() const;
  inline void clear_crop();
  static const int kCropFieldNumber = 2;
  inline const ::caffe_neural::PrepCropParam& crop() const;
  inline ::caffe_neural::PrepCropParam* mutable_crop();
  inline ::caffe_neural::PrepCropParam* release_crop();
  inline void set_allocated_crop(::caffe_neural::PrepCropParam* crop);

  // optional .caffe_neural.PrepClaheParam clahe = 3;
  inline bool has_clahe() const;
  inline void clear_clahe();
  static const int kClaheFieldNumber = 3;
  inline const ::caffe_neural::PrepClaheParam& clahe() const;
  inline ::caffe_neural::PrepClaheParam* mutable_clahe();
  inline ::caffe_neural::PrepClaheParam* release_clahe();
  inline void set_allocated_clahe(::caffe_neural::PrepClaheParam* clahe);

  // optional bool rotation = 4 [default = false];
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 4;
  inline bool rotation() const;
  inline void set_rotation(bool value);

  // optional bool mirror = 5 [default = false];
  inline bool has_mirror() const;
  inline void clear_mirror();
  static const int kMirrorFieldNumber = 5;
  inline bool mirror() const;
  inline void set_mirror(bool value);

  // optional .caffe_neural.PrepHistEqParam histeq = 6;
  inline bool has_histeq() const;
  inline void clear_histeq();
  static const int kHisteqFieldNumber = 6;
  inline const ::caffe_neural::PrepHistEqParam& histeq() const;
  inline ::caffe_neural::PrepHistEqParam* mutable_histeq();
  inline ::caffe_neural::PrepHistEqParam* release_histeq();
  inline void set_allocated_histeq(::caffe_neural::PrepHistEqParam* histeq);

  // optional .caffe_neural.PrepBlurParam blur = 7;
  inline bool has_blur() const;
  inline void clear_blur();
  static const int kBlurFieldNumber = 7;
  inline const ::caffe_neural::PrepBlurParam& blur() const;
  inline ::caffe_neural::PrepBlurParam* mutable_blur();
  inline ::caffe_neural::PrepBlurParam* release_blur();
  inline void set_allocated_blur(::caffe_neural::PrepBlurParam* blur);

  // optional .caffe_neural.PrepDeformParam deform = 8;
  inline bool has_deform() const;
  inline void clear_deform();
  static const int kDeformFieldNumber = 8;
  inline const ::caffe_neural::PrepDeformParam& deform() const;
  inline ::caffe_neural::PrepDeformParam* mutable_deform();
  inline ::caffe_neural::PrepDeformParam* release_deform();
  inline void set_allocated_deform(::caffe_neural::PrepDeformParam* deform);

  // @@protoc_insertion_point(class_scope:caffe_neural.PreprocessorParam)
 private:
  inline void set_has_normalization();
  inline void clear_has_normalization();
  inline void set_has_crop();
  inline void clear_has_crop();
  inline void set_has_clahe();
  inline void clear_has_clahe();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_mirror();
  inline void clear_has_mirror();
  inline void set_has_histeq();
  inline void clear_has_histeq();
  inline void set_has_blur();
  inline void clear_has_blur();
  inline void set_has_deform();
  inline void clear_has_deform();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::caffe_neural::PrepCropParam* crop_;
  ::caffe_neural::PrepClaheParam* clahe_;
  ::caffe_neural::PrepHistEqParam* histeq_;
  ::caffe_neural::PrepBlurParam* blur_;
  ::caffe_neural::PrepDeformParam* deform_;
  bool normalization_;
  bool rotation_;
  bool mirror_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static PreprocessorParam* default_instance_;
};
// -------------------------------------------------------------------

class PrepCropParam : public ::google::protobuf::Message {
 public:
  PrepCropParam();
  virtual ~PrepCropParam();

  PrepCropParam(const PrepCropParam& from);

  inline PrepCropParam& operator=(const PrepCropParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepCropParam& default_instance();

  void Swap(PrepCropParam* other);

  // implements Message ----------------------------------------------

  PrepCropParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrepCropParam& from);
  void MergeFrom(const PrepCropParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 imagecrop = 1;
  inline bool has_imagecrop() const;
  inline void clear_imagecrop();
  static const int kImagecropFieldNumber = 1;
  inline ::google::protobuf::int32 imagecrop() const;
  inline void set_imagecrop(::google::protobuf::int32 value);

  // optional int32 labelcrop = 2;
  inline bool has_labelcrop() const;
  inline void clear_labelcrop();
  static const int kLabelcropFieldNumber = 2;
  inline ::google::protobuf::int32 labelcrop() const;
  inline void set_labelcrop(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe_neural.PrepCropParam)
 private:
  inline void set_has_imagecrop();
  inline void clear_has_imagecrop();
  inline void set_has_labelcrop();
  inline void clear_has_labelcrop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 imagecrop_;
  ::google::protobuf::int32 labelcrop_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static PrepCropParam* default_instance_;
};
// -------------------------------------------------------------------

class PrepBlurParam : public ::google::protobuf::Message {
 public:
  PrepBlurParam();
  virtual ~PrepBlurParam();

  PrepBlurParam(const PrepBlurParam& from);

  inline PrepBlurParam& operator=(const PrepBlurParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepBlurParam& default_instance();

  void Swap(PrepBlurParam* other);

  // implements Message ----------------------------------------------

  PrepBlurParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrepBlurParam& from);
  void MergeFrom(const PrepBlurParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float mean = 1 [default = 0];
  inline bool has_mean() const;
  inline void clear_mean();
  static const int kMeanFieldNumber = 1;
  inline float mean() const;
  inline void set_mean(float value);

  // optional float std = 2 [default = 0.1];
  inline bool has_std() const;
  inline void clear_std();
  static const int kStdFieldNumber = 2;
  inline float std() const;
  inline void set_std(float value);

  // optional int32 ksize = 3 [default = 5];
  inline bool has_ksize() const;
  inline void clear_ksize();
  static const int kKsizeFieldNumber = 3;
  inline ::google::protobuf::int32 ksize() const;
  inline void set_ksize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe_neural.PrepBlurParam)
 private:
  inline void set_has_mean();
  inline void clear_has_mean();
  inline void set_has_std();
  inline void clear_has_std();
  inline void set_has_ksize();
  inline void clear_has_ksize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float mean_;
  float std_;
  ::google::protobuf::int32 ksize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static PrepBlurParam* default_instance_;
};
// -------------------------------------------------------------------

class PrepDeformParam : public ::google::protobuf::Message {
 public:
  PrepDeformParam();
  virtual ~PrepDeformParam();

  PrepDeformParam(const PrepDeformParam& from);

  inline PrepDeformParam& operator=(const PrepDeformParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepDeformParam& default_instance();

  void Swap(PrepDeformParam* other);

  // implements Message ----------------------------------------------

  PrepDeformParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrepDeformParam& from);
  void MergeFrom(const PrepDeformParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float mean_x = 1 [default = 0];
  inline bool has_mean_x() const;
  inline void clear_mean_x();
  static const int kMeanXFieldNumber = 1;
  inline float mean_x() const;
  inline void set_mean_x(float value);

  // optional float mean_y = 2 [default = 0];
  inline bool has_mean_y() const;
  inline void clear_mean_y();
  static const int kMeanYFieldNumber = 2;
  inline float mean_y() const;
  inline void set_mean_y(float value);

  // optional float std_x = 3 [default = 0.1];
  inline bool has_std_x() const;
  inline void clear_std_x();
  static const int kStdXFieldNumber = 3;
  inline float std_x() const;
  inline void set_std_x(float value);

  // optional float std_y = 4 [default = 0.1];
  inline bool has_std_y() const;
  inline void clear_std_y();
  static const int kStdYFieldNumber = 4;
  inline float std_y() const;
  inline void set_std_y(float value);

  // @@protoc_insertion_point(class_scope:caffe_neural.PrepDeformParam)
 private:
  inline void set_has_mean_x();
  inline void clear_has_mean_x();
  inline void set_has_mean_y();
  inline void clear_has_mean_y();
  inline void set_has_std_x();
  inline void clear_has_std_x();
  inline void set_has_std_y();
  inline void clear_has_std_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float mean_x_;
  float mean_y_;
  float std_x_;
  float std_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static PrepDeformParam* default_instance_;
};
// -------------------------------------------------------------------

class PrepClaheParam : public ::google::protobuf::Message {
 public:
  PrepClaheParam();
  virtual ~PrepClaheParam();

  PrepClaheParam(const PrepClaheParam& from);

  inline PrepClaheParam& operator=(const PrepClaheParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepClaheParam& default_instance();

  void Swap(PrepClaheParam* other);

  // implements Message ----------------------------------------------

  PrepClaheParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrepClaheParam& from);
  void MergeFrom(const PrepClaheParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float clip = 1 [default = 4];
  inline bool has_clip() const;
  inline void clear_clip();
  static const int kClipFieldNumber = 1;
  inline float clip() const;
  inline void set_clip(float value);

  // @@protoc_insertion_point(class_scope:caffe_neural.PrepClaheParam)
 private:
  inline void set_has_clip();
  inline void clear_has_clip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float clip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static PrepClaheParam* default_instance_;
};
// -------------------------------------------------------------------

class PrepHistEqParam : public ::google::protobuf::Message {
 public:
  PrepHistEqParam();
  virtual ~PrepHistEqParam();

  PrepHistEqParam(const PrepHistEqParam& from);

  inline PrepHistEqParam& operator=(const PrepHistEqParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepHistEqParam& default_instance();

  void Swap(PrepHistEqParam* other);

  // implements Message ----------------------------------------------

  PrepHistEqParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrepHistEqParam& from);
  void MergeFrom(const PrepHistEqParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool patch_prior = 1 [default = true];
  inline bool has_patch_prior() const;
  inline void clear_patch_prior();
  static const int kPatchPriorFieldNumber = 1;
  inline bool patch_prior() const;
  inline void set_patch_prior(bool value);

  // optional bool masking = 2 [default = false];
  inline bool has_masking() const;
  inline void clear_masking();
  static const int kMaskingFieldNumber = 2;
  inline bool masking() const;
  inline void set_masking(bool value);

  // repeated float label_boost = 3;
  inline int label_boost_size() const;
  inline void clear_label_boost();
  static const int kLabelBoostFieldNumber = 3;
  inline float label_boost(int index) const;
  inline void set_label_boost(int index, float value);
  inline void add_label_boost(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      label_boost() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_label_boost();

  // optional float border_boost = 4 [default = 1];
  inline bool has_border_boost() const;
  inline void clear_border_boost();
  static const int kBorderBoostFieldNumber = 4;
  inline float border_boost() const;
  inline void set_border_boost(float value);

  // @@protoc_insertion_point(class_scope:caffe_neural.PrepHistEqParam)
 private:
  inline void set_has_patch_prior();
  inline void clear_has_patch_prior();
  inline void set_has_masking();
  inline void clear_has_masking();
  inline void set_has_border_boost();
  inline void clear_has_border_boost();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool patch_prior_;
  bool masking_;
  float border_boost_;
  ::google::protobuf::RepeatedField< float > label_boost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_caffetool_2eproto();
  friend void protobuf_AssignDesc_caffetool_2eproto();
  friend void protobuf_ShutdownFile_caffetool_2eproto();

  void InitAsDefaultInstance();
  static PrepHistEqParam* default_instance_;
};
// ===================================================================


// ===================================================================

// ToolParam

// repeated .caffe_neural.TrainParam train = 1;
inline int ToolParam::train_size() const {
  return train_.size();
}
inline void ToolParam::clear_train() {
  train_.Clear();
}
inline const ::caffe_neural::TrainParam& ToolParam::train(int index) const {
  return train_.Get(index);
}
inline ::caffe_neural::TrainParam* ToolParam::mutable_train(int index) {
  return train_.Mutable(index);
}
inline ::caffe_neural::TrainParam* ToolParam::add_train() {
  return train_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe_neural::TrainParam >&
ToolParam::train() const {
  return train_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe_neural::TrainParam >*
ToolParam::mutable_train() {
  return &train_;
}

// repeated .caffe_neural.ProcessParam process = 2;
inline int ToolParam::process_size() const {
  return process_.size();
}
inline void ToolParam::clear_process() {
  process_.Clear();
}
inline const ::caffe_neural::ProcessParam& ToolParam::process(int index) const {
  return process_.Get(index);
}
inline ::caffe_neural::ProcessParam* ToolParam::mutable_process(int index) {
  return process_.Mutable(index);
}
inline ::caffe_neural::ProcessParam* ToolParam::add_process() {
  return process_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe_neural::ProcessParam >&
ToolParam::process() const {
  return process_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe_neural::ProcessParam >*
ToolParam::mutable_process() {
  return &process_;
}

// repeated .caffe_neural.BenchmarkParam benchmark = 3;
inline int ToolParam::benchmark_size() const {
  return benchmark_.size();
}
inline void ToolParam::clear_benchmark() {
  benchmark_.Clear();
}
inline const ::caffe_neural::BenchmarkParam& ToolParam::benchmark(int index) const {
  return benchmark_.Get(index);
}
inline ::caffe_neural::BenchmarkParam* ToolParam::mutable_benchmark(int index) {
  return benchmark_.Mutable(index);
}
inline ::caffe_neural::BenchmarkParam* ToolParam::add_benchmark() {
  return benchmark_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe_neural::BenchmarkParam >&
ToolParam::benchmark() const {
  return benchmark_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe_neural::BenchmarkParam >*
ToolParam::mutable_benchmark() {
  return &benchmark_;
}

// -------------------------------------------------------------------

// BenchmarkParam

// optional int32 bench_runs = 1;
inline bool BenchmarkParam::has_bench_runs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BenchmarkParam::set_has_bench_runs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BenchmarkParam::clear_has_bench_runs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BenchmarkParam::clear_bench_runs() {
  bench_runs_ = 0;
  clear_has_bench_runs();
}
inline ::google::protobuf::int32 BenchmarkParam::bench_runs() const {
  return bench_runs_;
}
inline void BenchmarkParam::set_bench_runs(::google::protobuf::int32 value) {
  set_has_bench_runs();
  bench_runs_ = value;
}

// optional int32 warmup_runs = 2;
inline bool BenchmarkParam::has_warmup_runs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BenchmarkParam::set_has_warmup_runs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BenchmarkParam::clear_has_warmup_runs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BenchmarkParam::clear_warmup_runs() {
  warmup_runs_ = 0;
  clear_has_warmup_runs();
}
inline ::google::protobuf::int32 BenchmarkParam::warmup_runs() const {
  return warmup_runs_;
}
inline void BenchmarkParam::set_warmup_runs(::google::protobuf::int32 value) {
  set_has_warmup_runs();
  warmup_runs_ = value;
}

// optional string output = 3;
inline bool BenchmarkParam::has_output() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BenchmarkParam::set_has_output() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BenchmarkParam::clear_has_output() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BenchmarkParam::clear_output() {
  if (output_ != &::google::protobuf::internal::kEmptyString) {
    output_->clear();
  }
  clear_has_output();
}
inline const ::std::string& BenchmarkParam::output() const {
  return *output_;
}
inline void BenchmarkParam::set_output(const ::std::string& value) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(value);
}
inline void BenchmarkParam::set_output(const char* value) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(value);
}
inline void BenchmarkParam::set_output(const char* value, size_t size) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BenchmarkParam::mutable_output() {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  return output_;
}
inline ::std::string* BenchmarkParam::release_output() {
  clear_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = output_;
    output_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BenchmarkParam::set_allocated_output(::std::string* output) {
  if (output_ != &::google::protobuf::internal::kEmptyString) {
    delete output_;
  }
  if (output) {
    set_has_output();
    output_ = output;
  } else {
    clear_has_output();
    output_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 train_index = 4;
inline bool BenchmarkParam::has_train_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BenchmarkParam::set_has_train_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BenchmarkParam::clear_has_train_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BenchmarkParam::clear_train_index() {
  train_index_ = 0;
  clear_has_train_index();
}
inline ::google::protobuf::int32 BenchmarkParam::train_index() const {
  return train_index_;
}
inline void BenchmarkParam::set_train_index(::google::protobuf::int32 value) {
  set_has_train_index();
  train_index_ = value;
}

// optional int32 process_index = 5;
inline bool BenchmarkParam::has_process_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BenchmarkParam::set_has_process_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BenchmarkParam::clear_has_process_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BenchmarkParam::clear_process_index() {
  process_index_ = 0;
  clear_has_process_index();
}
inline ::google::protobuf::int32 BenchmarkParam::process_index() const {
  return process_index_;
}
inline void BenchmarkParam::set_process_index(::google::protobuf::int32 value) {
  set_has_process_index();
  process_index_ = value;
}

// -------------------------------------------------------------------

// TrainParam

// optional string solver = 1;
inline bool TrainParam::has_solver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrainParam::set_has_solver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrainParam::clear_has_solver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrainParam::clear_solver() {
  if (solver_ != &::google::protobuf::internal::kEmptyString) {
    solver_->clear();
  }
  clear_has_solver();
}
inline const ::std::string& TrainParam::solver() const {
  return *solver_;
}
inline void TrainParam::set_solver(const ::std::string& value) {
  set_has_solver();
  if (solver_ == &::google::protobuf::internal::kEmptyString) {
    solver_ = new ::std::string;
  }
  solver_->assign(value);
}
inline void TrainParam::set_solver(const char* value) {
  set_has_solver();
  if (solver_ == &::google::protobuf::internal::kEmptyString) {
    solver_ = new ::std::string;
  }
  solver_->assign(value);
}
inline void TrainParam::set_solver(const char* value, size_t size) {
  set_has_solver();
  if (solver_ == &::google::protobuf::internal::kEmptyString) {
    solver_ = new ::std::string;
  }
  solver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrainParam::mutable_solver() {
  set_has_solver();
  if (solver_ == &::google::protobuf::internal::kEmptyString) {
    solver_ = new ::std::string;
  }
  return solver_;
}
inline ::std::string* TrainParam::release_solver() {
  clear_has_solver();
  if (solver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = solver_;
    solver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrainParam::set_allocated_solver(::std::string* solver) {
  if (solver_ != &::google::protobuf::internal::kEmptyString) {
    delete solver_;
  }
  if (solver) {
    set_has_solver();
    solver_ = solver;
  } else {
    clear_has_solver();
    solver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string solverstate = 2;
inline bool TrainParam::has_solverstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrainParam::set_has_solverstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrainParam::clear_has_solverstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrainParam::clear_solverstate() {
  if (solverstate_ != &::google::protobuf::internal::kEmptyString) {
    solverstate_->clear();
  }
  clear_has_solverstate();
}
inline const ::std::string& TrainParam::solverstate() const {
  return *solverstate_;
}
inline void TrainParam::set_solverstate(const ::std::string& value) {
  set_has_solverstate();
  if (solverstate_ == &::google::protobuf::internal::kEmptyString) {
    solverstate_ = new ::std::string;
  }
  solverstate_->assign(value);
}
inline void TrainParam::set_solverstate(const char* value) {
  set_has_solverstate();
  if (solverstate_ == &::google::protobuf::internal::kEmptyString) {
    solverstate_ = new ::std::string;
  }
  solverstate_->assign(value);
}
inline void TrainParam::set_solverstate(const char* value, size_t size) {
  set_has_solverstate();
  if (solverstate_ == &::google::protobuf::internal::kEmptyString) {
    solverstate_ = new ::std::string;
  }
  solverstate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrainParam::mutable_solverstate() {
  set_has_solverstate();
  if (solverstate_ == &::google::protobuf::internal::kEmptyString) {
    solverstate_ = new ::std::string;
  }
  return solverstate_;
}
inline ::std::string* TrainParam::release_solverstate() {
  clear_has_solverstate();
  if (solverstate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = solverstate_;
    solverstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrainParam::set_allocated_solverstate(::std::string* solverstate) {
  if (solverstate_ != &::google::protobuf::internal::kEmptyString) {
    delete solverstate_;
  }
  if (solverstate) {
    set_has_solverstate();
    solverstate_ = solverstate;
  } else {
    clear_has_solverstate();
    solverstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .caffe_neural.InputParam input = 3;
inline bool TrainParam::has_input() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrainParam::set_has_input() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrainParam::clear_has_input() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrainParam::clear_input() {
  if (input_ != NULL) input_->::caffe_neural::InputParam::Clear();
  clear_has_input();
}
inline const ::caffe_neural::InputParam& TrainParam::input() const {
  return input_ != NULL ? *input_ : *default_instance_->input_;
}
inline ::caffe_neural::InputParam* TrainParam::mutable_input() {
  set_has_input();
  if (input_ == NULL) input_ = new ::caffe_neural::InputParam;
  return input_;
}
inline ::caffe_neural::InputParam* TrainParam::release_input() {
  clear_has_input();
  ::caffe_neural::InputParam* temp = input_;
  input_ = NULL;
  return temp;
}
inline void TrainParam::set_allocated_input(::caffe_neural::InputParam* input) {
  delete input_;
  input_ = input;
  if (input) {
    set_has_input();
  } else {
    clear_has_input();
  }
}

// -------------------------------------------------------------------

// ProcessParam

// optional string process_net = 1;
inline bool ProcessParam::has_process_net() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessParam::set_has_process_net() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessParam::clear_has_process_net() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessParam::clear_process_net() {
  if (process_net_ != &::google::protobuf::internal::kEmptyString) {
    process_net_->clear();
  }
  clear_has_process_net();
}
inline const ::std::string& ProcessParam::process_net() const {
  return *process_net_;
}
inline void ProcessParam::set_process_net(const ::std::string& value) {
  set_has_process_net();
  if (process_net_ == &::google::protobuf::internal::kEmptyString) {
    process_net_ = new ::std::string;
  }
  process_net_->assign(value);
}
inline void ProcessParam::set_process_net(const char* value) {
  set_has_process_net();
  if (process_net_ == &::google::protobuf::internal::kEmptyString) {
    process_net_ = new ::std::string;
  }
  process_net_->assign(value);
}
inline void ProcessParam::set_process_net(const char* value, size_t size) {
  set_has_process_net();
  if (process_net_ == &::google::protobuf::internal::kEmptyString) {
    process_net_ = new ::std::string;
  }
  process_net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessParam::mutable_process_net() {
  set_has_process_net();
  if (process_net_ == &::google::protobuf::internal::kEmptyString) {
    process_net_ = new ::std::string;
  }
  return process_net_;
}
inline ::std::string* ProcessParam::release_process_net() {
  clear_has_process_net();
  if (process_net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = process_net_;
    process_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcessParam::set_allocated_process_net(::std::string* process_net) {
  if (process_net_ != &::google::protobuf::internal::kEmptyString) {
    delete process_net_;
  }
  if (process_net) {
    set_has_process_net();
    process_net_ = process_net;
  } else {
    clear_has_process_net();
    process_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string caffemodel = 2;
inline bool ProcessParam::has_caffemodel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessParam::set_has_caffemodel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessParam::clear_has_caffemodel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessParam::clear_caffemodel() {
  if (caffemodel_ != &::google::protobuf::internal::kEmptyString) {
    caffemodel_->clear();
  }
  clear_has_caffemodel();
}
inline const ::std::string& ProcessParam::caffemodel() const {
  return *caffemodel_;
}
inline void ProcessParam::set_caffemodel(const ::std::string& value) {
  set_has_caffemodel();
  if (caffemodel_ == &::google::protobuf::internal::kEmptyString) {
    caffemodel_ = new ::std::string;
  }
  caffemodel_->assign(value);
}
inline void ProcessParam::set_caffemodel(const char* value) {
  set_has_caffemodel();
  if (caffemodel_ == &::google::protobuf::internal::kEmptyString) {
    caffemodel_ = new ::std::string;
  }
  caffemodel_->assign(value);
}
inline void ProcessParam::set_caffemodel(const char* value, size_t size) {
  set_has_caffemodel();
  if (caffemodel_ == &::google::protobuf::internal::kEmptyString) {
    caffemodel_ = new ::std::string;
  }
  caffemodel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessParam::mutable_caffemodel() {
  set_has_caffemodel();
  if (caffemodel_ == &::google::protobuf::internal::kEmptyString) {
    caffemodel_ = new ::std::string;
  }
  return caffemodel_;
}
inline ::std::string* ProcessParam::release_caffemodel() {
  clear_has_caffemodel();
  if (caffemodel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caffemodel_;
    caffemodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcessParam::set_allocated_caffemodel(::std::string* caffemodel) {
  if (caffemodel_ != &::google::protobuf::internal::kEmptyString) {
    delete caffemodel_;
  }
  if (caffemodel) {
    set_has_caffemodel();
    caffemodel_ = caffemodel;
  } else {
    clear_has_caffemodel();
    caffemodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .caffe_neural.InputParam input = 3;
inline bool ProcessParam::has_input() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessParam::set_has_input() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessParam::clear_has_input() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessParam::clear_input() {
  if (input_ != NULL) input_->::caffe_neural::InputParam::Clear();
  clear_has_input();
}
inline const ::caffe_neural::InputParam& ProcessParam::input() const {
  return input_ != NULL ? *input_ : *default_instance_->input_;
}
inline ::caffe_neural::InputParam* ProcessParam::mutable_input() {
  set_has_input();
  if (input_ == NULL) input_ = new ::caffe_neural::InputParam;
  return input_;
}
inline ::caffe_neural::InputParam* ProcessParam::release_input() {
  clear_has_input();
  ::caffe_neural::InputParam* temp = input_;
  input_ = NULL;
  return temp;
}
inline void ProcessParam::set_allocated_input(::caffe_neural::InputParam* input) {
  delete input_;
  input_ = input;
  if (input) {
    set_has_input();
  } else {
    clear_has_input();
  }
}

// optional .caffe_neural.OutputParam output = 4;
inline bool ProcessParam::has_output() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcessParam::set_has_output() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcessParam::clear_has_output() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcessParam::clear_output() {
  if (output_ != NULL) output_->::caffe_neural::OutputParam::Clear();
  clear_has_output();
}
inline const ::caffe_neural::OutputParam& ProcessParam::output() const {
  return output_ != NULL ? *output_ : *default_instance_->output_;
}
inline ::caffe_neural::OutputParam* ProcessParam::mutable_output() {
  set_has_output();
  if (output_ == NULL) output_ = new ::caffe_neural::OutputParam;
  return output_;
}
inline ::caffe_neural::OutputParam* ProcessParam::release_output() {
  clear_has_output();
  ::caffe_neural::OutputParam* temp = output_;
  output_ = NULL;
  return temp;
}
inline void ProcessParam::set_allocated_output(::caffe_neural::OutputParam* output) {
  delete output_;
  output_ = output;
  if (output) {
    set_has_output();
  } else {
    clear_has_output();
  }
}

// optional .caffe_neural.FilterOutputParam filter_output = 5;
inline bool ProcessParam::has_filter_output() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProcessParam::set_has_filter_output() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProcessParam::clear_has_filter_output() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProcessParam::clear_filter_output() {
  if (filter_output_ != NULL) filter_output_->::caffe_neural::FilterOutputParam::Clear();
  clear_has_filter_output();
}
inline const ::caffe_neural::FilterOutputParam& ProcessParam::filter_output() const {
  return filter_output_ != NULL ? *filter_output_ : *default_instance_->filter_output_;
}
inline ::caffe_neural::FilterOutputParam* ProcessParam::mutable_filter_output() {
  set_has_filter_output();
  if (filter_output_ == NULL) filter_output_ = new ::caffe_neural::FilterOutputParam;
  return filter_output_;
}
inline ::caffe_neural::FilterOutputParam* ProcessParam::release_filter_output() {
  clear_has_filter_output();
  ::caffe_neural::FilterOutputParam* temp = filter_output_;
  filter_output_ = NULL;
  return temp;
}
inline void ProcessParam::set_allocated_filter_output(::caffe_neural::FilterOutputParam* filter_output) {
  delete filter_output_;
  filter_output_ = filter_output;
  if (filter_output) {
    set_has_filter_output();
  } else {
    clear_has_filter_output();
  }
}

// -------------------------------------------------------------------

// FilterOutputParam

// optional bool output_filters = 1;
inline bool FilterOutputParam::has_output_filters() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterOutputParam::set_has_output_filters() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterOutputParam::clear_has_output_filters() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterOutputParam::clear_output_filters() {
  output_filters_ = false;
  clear_has_output_filters();
}
inline bool FilterOutputParam::output_filters() const {
  return output_filters_;
}
inline void FilterOutputParam::set_output_filters(bool value) {
  set_has_output_filters();
  output_filters_ = value;
}

// optional string output = 2;
inline bool FilterOutputParam::has_output() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterOutputParam::set_has_output() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterOutputParam::clear_has_output() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterOutputParam::clear_output() {
  if (output_ != &::google::protobuf::internal::kEmptyString) {
    output_->clear();
  }
  clear_has_output();
}
inline const ::std::string& FilterOutputParam::output() const {
  return *output_;
}
inline void FilterOutputParam::set_output(const ::std::string& value) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(value);
}
inline void FilterOutputParam::set_output(const char* value) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(value);
}
inline void FilterOutputParam::set_output(const char* value, size_t size) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FilterOutputParam::mutable_output() {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  return output_;
}
inline ::std::string* FilterOutputParam::release_output() {
  clear_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = output_;
    output_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FilterOutputParam::set_allocated_output(::std::string* output) {
  if (output_ != &::google::protobuf::internal::kEmptyString) {
    delete output_;
  }
  if (output) {
    set_has_output();
    output_ = output;
  } else {
    clear_has_output();
    output_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InputParam

// optional int32 padding_size = 1;
inline bool InputParam::has_padding_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputParam::set_has_padding_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputParam::clear_has_padding_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputParam::clear_padding_size() {
  padding_size_ = 0;
  clear_has_padding_size();
}
inline ::google::protobuf::int32 InputParam::padding_size() const {
  return padding_size_;
}
inline void InputParam::set_padding_size(::google::protobuf::int32 value) {
  set_has_padding_size();
  padding_size_ = value;
}

// optional int32 patch_size = 2;
inline bool InputParam::has_patch_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputParam::set_has_patch_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputParam::clear_has_patch_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputParam::clear_patch_size() {
  patch_size_ = 0;
  clear_has_patch_size();
}
inline ::google::protobuf::int32 InputParam::patch_size() const {
  return patch_size_;
}
inline void InputParam::set_patch_size(::google::protobuf::int32 value) {
  set_has_patch_size();
  patch_size_ = value;
}

// optional int32 channels = 3;
inline bool InputParam::has_channels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputParam::set_has_channels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InputParam::clear_has_channels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InputParam::clear_channels() {
  channels_ = 0;
  clear_has_channels();
}
inline ::google::protobuf::int32 InputParam::channels() const {
  return channels_;
}
inline void InputParam::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
}

// optional int32 labels = 4;
inline bool InputParam::has_labels() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InputParam::set_has_labels() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InputParam::clear_has_labels() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InputParam::clear_labels() {
  labels_ = 0;
  clear_has_labels();
}
inline ::google::protobuf::int32 InputParam::labels() const {
  return labels_;
}
inline void InputParam::set_labels(::google::protobuf::int32 value) {
  set_has_labels();
  labels_ = value;
}

// optional int32 batch_size = 5;
inline bool InputParam::has_batch_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InputParam::set_has_batch_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InputParam::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InputParam::clear_batch_size() {
  batch_size_ = 0;
  clear_has_batch_size();
}
inline ::google::protobuf::int32 InputParam::batch_size() const {
  return batch_size_;
}
inline void InputParam::set_batch_size(::google::protobuf::int32 value) {
  set_has_batch_size();
  batch_size_ = value;
}

// optional .caffe_neural.PreprocessorParam preprocessor = 6;
inline bool InputParam::has_preprocessor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InputParam::set_has_preprocessor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InputParam::clear_has_preprocessor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InputParam::clear_preprocessor() {
  if (preprocessor_ != NULL) preprocessor_->::caffe_neural::PreprocessorParam::Clear();
  clear_has_preprocessor();
}
inline const ::caffe_neural::PreprocessorParam& InputParam::preprocessor() const {
  return preprocessor_ != NULL ? *preprocessor_ : *default_instance_->preprocessor_;
}
inline ::caffe_neural::PreprocessorParam* InputParam::mutable_preprocessor() {
  set_has_preprocessor();
  if (preprocessor_ == NULL) preprocessor_ = new ::caffe_neural::PreprocessorParam;
  return preprocessor_;
}
inline ::caffe_neural::PreprocessorParam* InputParam::release_preprocessor() {
  clear_has_preprocessor();
  ::caffe_neural::PreprocessorParam* temp = preprocessor_;
  preprocessor_ = NULL;
  return temp;
}
inline void InputParam::set_allocated_preprocessor(::caffe_neural::PreprocessorParam* preprocessor) {
  delete preprocessor_;
  preprocessor_ = preprocessor;
  if (preprocessor) {
    set_has_preprocessor();
  } else {
    clear_has_preprocessor();
  }
}

// optional string raw_images = 7;
inline bool InputParam::has_raw_images() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InputParam::set_has_raw_images() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InputParam::clear_has_raw_images() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InputParam::clear_raw_images() {
  if (raw_images_ != &::google::protobuf::internal::kEmptyString) {
    raw_images_->clear();
  }
  clear_has_raw_images();
}
inline const ::std::string& InputParam::raw_images() const {
  return *raw_images_;
}
inline void InputParam::set_raw_images(const ::std::string& value) {
  set_has_raw_images();
  if (raw_images_ == &::google::protobuf::internal::kEmptyString) {
    raw_images_ = new ::std::string;
  }
  raw_images_->assign(value);
}
inline void InputParam::set_raw_images(const char* value) {
  set_has_raw_images();
  if (raw_images_ == &::google::protobuf::internal::kEmptyString) {
    raw_images_ = new ::std::string;
  }
  raw_images_->assign(value);
}
inline void InputParam::set_raw_images(const char* value, size_t size) {
  set_has_raw_images();
  if (raw_images_ == &::google::protobuf::internal::kEmptyString) {
    raw_images_ = new ::std::string;
  }
  raw_images_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InputParam::mutable_raw_images() {
  set_has_raw_images();
  if (raw_images_ == &::google::protobuf::internal::kEmptyString) {
    raw_images_ = new ::std::string;
  }
  return raw_images_;
}
inline ::std::string* InputParam::release_raw_images() {
  clear_has_raw_images();
  if (raw_images_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = raw_images_;
    raw_images_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InputParam::set_allocated_raw_images(::std::string* raw_images) {
  if (raw_images_ != &::google::protobuf::internal::kEmptyString) {
    delete raw_images_;
  }
  if (raw_images) {
    set_has_raw_images();
    raw_images_ = raw_images;
  } else {
    clear_has_raw_images();
    raw_images_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string label_images = 8;
inline bool InputParam::has_label_images() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InputParam::set_has_label_images() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InputParam::clear_has_label_images() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InputParam::clear_label_images() {
  if (label_images_ != &::google::protobuf::internal::kEmptyString) {
    label_images_->clear();
  }
  clear_has_label_images();
}
inline const ::std::string& InputParam::label_images() const {
  return *label_images_;
}
inline void InputParam::set_label_images(const ::std::string& value) {
  set_has_label_images();
  if (label_images_ == &::google::protobuf::internal::kEmptyString) {
    label_images_ = new ::std::string;
  }
  label_images_->assign(value);
}
inline void InputParam::set_label_images(const char* value) {
  set_has_label_images();
  if (label_images_ == &::google::protobuf::internal::kEmptyString) {
    label_images_ = new ::std::string;
  }
  label_images_->assign(value);
}
inline void InputParam::set_label_images(const char* value, size_t size) {
  set_has_label_images();
  if (label_images_ == &::google::protobuf::internal::kEmptyString) {
    label_images_ = new ::std::string;
  }
  label_images_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InputParam::mutable_label_images() {
  set_has_label_images();
  if (label_images_ == &::google::protobuf::internal::kEmptyString) {
    label_images_ = new ::std::string;
  }
  return label_images_;
}
inline ::std::string* InputParam::release_label_images() {
  clear_has_label_images();
  if (label_images_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_images_;
    label_images_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InputParam::set_allocated_label_images(::std::string* label_images) {
  if (label_images_ != &::google::protobuf::internal::kEmptyString) {
    delete label_images_;
  }
  if (label_images) {
    set_has_label_images();
    label_images_ = label_images;
  } else {
    clear_has_label_images();
    label_images_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OutputParam

// optional string output = 1;
inline bool OutputParam::has_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OutputParam::set_has_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OutputParam::clear_has_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OutputParam::clear_output() {
  if (output_ != &::google::protobuf::internal::kEmptyString) {
    output_->clear();
  }
  clear_has_output();
}
inline const ::std::string& OutputParam::output() const {
  return *output_;
}
inline void OutputParam::set_output(const ::std::string& value) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(value);
}
inline void OutputParam::set_output(const char* value) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(value);
}
inline void OutputParam::set_output(const char* value, size_t size) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputParam::mutable_output() {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  return output_;
}
inline ::std::string* OutputParam::release_output() {
  clear_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = output_;
    output_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OutputParam::set_allocated_output(::std::string* output) {
  if (output_ != &::google::protobuf::internal::kEmptyString) {
    delete output_;
  }
  if (output) {
    set_has_output();
    output_ = output;
  } else {
    clear_has_output();
    output_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool fp32_out = 2 [default = false];
inline bool OutputParam::has_fp32_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OutputParam::set_has_fp32_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OutputParam::clear_has_fp32_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OutputParam::clear_fp32_out() {
  fp32_out_ = false;
  clear_has_fp32_out();
}
inline bool OutputParam::fp32_out() const {
  return fp32_out_;
}
inline void OutputParam::set_fp32_out(bool value) {
  set_has_fp32_out();
  fp32_out_ = value;
}

// optional bool out_all_labels = 3 [default = false];
inline bool OutputParam::has_out_all_labels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OutputParam::set_has_out_all_labels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OutputParam::clear_has_out_all_labels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OutputParam::clear_out_all_labels() {
  out_all_labels_ = false;
  clear_has_out_all_labels();
}
inline bool OutputParam::out_all_labels() const {
  return out_all_labels_;
}
inline void OutputParam::set_out_all_labels(bool value) {
  set_has_out_all_labels();
  out_all_labels_ = value;
}

// optional string format = 4 [default = "tif"];
inline bool OutputParam::has_format() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OutputParam::set_has_format() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OutputParam::clear_has_format() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OutputParam::clear_format() {
  if (format_ != _default_format_) {
    format_->assign(*_default_format_);
  }
  clear_has_format();
}
inline const ::std::string& OutputParam::format() const {
  return *format_;
}
inline void OutputParam::set_format(const ::std::string& value) {
  set_has_format();
  if (format_ == _default_format_) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void OutputParam::set_format(const char* value) {
  set_has_format();
  if (format_ == _default_format_) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void OutputParam::set_format(const char* value, size_t size) {
  set_has_format();
  if (format_ == _default_format_) {
    format_ = new ::std::string;
  }
  format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputParam::mutable_format() {
  set_has_format();
  if (format_ == _default_format_) {
    format_ = new ::std::string(*_default_format_);
  }
  return format_;
}
inline ::std::string* OutputParam::release_format() {
  clear_has_format();
  if (format_ == _default_format_) {
    return NULL;
  } else {
    ::std::string* temp = format_;
    format_ = const_cast< ::std::string*>(_default_format_);
    return temp;
  }
}
inline void OutputParam::set_allocated_format(::std::string* format) {
  if (format_ != _default_format_) {
    delete format_;
  }
  if (format) {
    set_has_format();
    format_ = format;
  } else {
    clear_has_format();
    format_ = const_cast< ::std::string*>(_default_format_);
  }
}

// -------------------------------------------------------------------

// PreprocessorParam

// optional bool normalization = 1 [default = true];
inline bool PreprocessorParam::has_normalization() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreprocessorParam::set_has_normalization() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreprocessorParam::clear_has_normalization() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreprocessorParam::clear_normalization() {
  normalization_ = true;
  clear_has_normalization();
}
inline bool PreprocessorParam::normalization() const {
  return normalization_;
}
inline void PreprocessorParam::set_normalization(bool value) {
  set_has_normalization();
  normalization_ = value;
}

// optional .caffe_neural.PrepCropParam crop = 2;
inline bool PreprocessorParam::has_crop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreprocessorParam::set_has_crop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreprocessorParam::clear_has_crop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreprocessorParam::clear_crop() {
  if (crop_ != NULL) crop_->::caffe_neural::PrepCropParam::Clear();
  clear_has_crop();
}
inline const ::caffe_neural::PrepCropParam& PreprocessorParam::crop() const {
  return crop_ != NULL ? *crop_ : *default_instance_->crop_;
}
inline ::caffe_neural::PrepCropParam* PreprocessorParam::mutable_crop() {
  set_has_crop();
  if (crop_ == NULL) crop_ = new ::caffe_neural::PrepCropParam;
  return crop_;
}
inline ::caffe_neural::PrepCropParam* PreprocessorParam::release_crop() {
  clear_has_crop();
  ::caffe_neural::PrepCropParam* temp = crop_;
  crop_ = NULL;
  return temp;
}
inline void PreprocessorParam::set_allocated_crop(::caffe_neural::PrepCropParam* crop) {
  delete crop_;
  crop_ = crop;
  if (crop) {
    set_has_crop();
  } else {
    clear_has_crop();
  }
}

// optional .caffe_neural.PrepClaheParam clahe = 3;
inline bool PreprocessorParam::has_clahe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PreprocessorParam::set_has_clahe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PreprocessorParam::clear_has_clahe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PreprocessorParam::clear_clahe() {
  if (clahe_ != NULL) clahe_->::caffe_neural::PrepClaheParam::Clear();
  clear_has_clahe();
}
inline const ::caffe_neural::PrepClaheParam& PreprocessorParam::clahe() const {
  return clahe_ != NULL ? *clahe_ : *default_instance_->clahe_;
}
inline ::caffe_neural::PrepClaheParam* PreprocessorParam::mutable_clahe() {
  set_has_clahe();
  if (clahe_ == NULL) clahe_ = new ::caffe_neural::PrepClaheParam;
  return clahe_;
}
inline ::caffe_neural::PrepClaheParam* PreprocessorParam::release_clahe() {
  clear_has_clahe();
  ::caffe_neural::PrepClaheParam* temp = clahe_;
  clahe_ = NULL;
  return temp;
}
inline void PreprocessorParam::set_allocated_clahe(::caffe_neural::PrepClaheParam* clahe) {
  delete clahe_;
  clahe_ = clahe;
  if (clahe) {
    set_has_clahe();
  } else {
    clear_has_clahe();
  }
}

// optional bool rotation = 4 [default = false];
inline bool PreprocessorParam::has_rotation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PreprocessorParam::set_has_rotation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PreprocessorParam::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PreprocessorParam::clear_rotation() {
  rotation_ = false;
  clear_has_rotation();
}
inline bool PreprocessorParam::rotation() const {
  return rotation_;
}
inline void PreprocessorParam::set_rotation(bool value) {
  set_has_rotation();
  rotation_ = value;
}

// optional bool mirror = 5 [default = false];
inline bool PreprocessorParam::has_mirror() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PreprocessorParam::set_has_mirror() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PreprocessorParam::clear_has_mirror() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PreprocessorParam::clear_mirror() {
  mirror_ = false;
  clear_has_mirror();
}
inline bool PreprocessorParam::mirror() const {
  return mirror_;
}
inline void PreprocessorParam::set_mirror(bool value) {
  set_has_mirror();
  mirror_ = value;
}

// optional .caffe_neural.PrepHistEqParam histeq = 6;
inline bool PreprocessorParam::has_histeq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PreprocessorParam::set_has_histeq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PreprocessorParam::clear_has_histeq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PreprocessorParam::clear_histeq() {
  if (histeq_ != NULL) histeq_->::caffe_neural::PrepHistEqParam::Clear();
  clear_has_histeq();
}
inline const ::caffe_neural::PrepHistEqParam& PreprocessorParam::histeq() const {
  return histeq_ != NULL ? *histeq_ : *default_instance_->histeq_;
}
inline ::caffe_neural::PrepHistEqParam* PreprocessorParam::mutable_histeq() {
  set_has_histeq();
  if (histeq_ == NULL) histeq_ = new ::caffe_neural::PrepHistEqParam;
  return histeq_;
}
inline ::caffe_neural::PrepHistEqParam* PreprocessorParam::release_histeq() {
  clear_has_histeq();
  ::caffe_neural::PrepHistEqParam* temp = histeq_;
  histeq_ = NULL;
  return temp;
}
inline void PreprocessorParam::set_allocated_histeq(::caffe_neural::PrepHistEqParam* histeq) {
  delete histeq_;
  histeq_ = histeq;
  if (histeq) {
    set_has_histeq();
  } else {
    clear_has_histeq();
  }
}

// optional .caffe_neural.PrepBlurParam blur = 7;
inline bool PreprocessorParam::has_blur() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PreprocessorParam::set_has_blur() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PreprocessorParam::clear_has_blur() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PreprocessorParam::clear_blur() {
  if (blur_ != NULL) blur_->::caffe_neural::PrepBlurParam::Clear();
  clear_has_blur();
}
inline const ::caffe_neural::PrepBlurParam& PreprocessorParam::blur() const {
  return blur_ != NULL ? *blur_ : *default_instance_->blur_;
}
inline ::caffe_neural::PrepBlurParam* PreprocessorParam::mutable_blur() {
  set_has_blur();
  if (blur_ == NULL) blur_ = new ::caffe_neural::PrepBlurParam;
  return blur_;
}
inline ::caffe_neural::PrepBlurParam* PreprocessorParam::release_blur() {
  clear_has_blur();
  ::caffe_neural::PrepBlurParam* temp = blur_;
  blur_ = NULL;
  return temp;
}
inline void PreprocessorParam::set_allocated_blur(::caffe_neural::PrepBlurParam* blur) {
  delete blur_;
  blur_ = blur;
  if (blur) {
    set_has_blur();
  } else {
    clear_has_blur();
  }
}

// optional .caffe_neural.PrepDeformParam deform = 8;
inline bool PreprocessorParam::has_deform() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PreprocessorParam::set_has_deform() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PreprocessorParam::clear_has_deform() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PreprocessorParam::clear_deform() {
  if (deform_ != NULL) deform_->::caffe_neural::PrepDeformParam::Clear();
  clear_has_deform();
}
inline const ::caffe_neural::PrepDeformParam& PreprocessorParam::deform() const {
  return deform_ != NULL ? *deform_ : *default_instance_->deform_;
}
inline ::caffe_neural::PrepDeformParam* PreprocessorParam::mutable_deform() {
  set_has_deform();
  if (deform_ == NULL) deform_ = new ::caffe_neural::PrepDeformParam;
  return deform_;
}
inline ::caffe_neural::PrepDeformParam* PreprocessorParam::release_deform() {
  clear_has_deform();
  ::caffe_neural::PrepDeformParam* temp = deform_;
  deform_ = NULL;
  return temp;
}
inline void PreprocessorParam::set_allocated_deform(::caffe_neural::PrepDeformParam* deform) {
  delete deform_;
  deform_ = deform;
  if (deform) {
    set_has_deform();
  } else {
    clear_has_deform();
  }
}

// -------------------------------------------------------------------

// PrepCropParam

// optional int32 imagecrop = 1;
inline bool PrepCropParam::has_imagecrop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrepCropParam::set_has_imagecrop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrepCropParam::clear_has_imagecrop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrepCropParam::clear_imagecrop() {
  imagecrop_ = 0;
  clear_has_imagecrop();
}
inline ::google::protobuf::int32 PrepCropParam::imagecrop() const {
  return imagecrop_;
}
inline void PrepCropParam::set_imagecrop(::google::protobuf::int32 value) {
  set_has_imagecrop();
  imagecrop_ = value;
}

// optional int32 labelcrop = 2;
inline bool PrepCropParam::has_labelcrop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrepCropParam::set_has_labelcrop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrepCropParam::clear_has_labelcrop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrepCropParam::clear_labelcrop() {
  labelcrop_ = 0;
  clear_has_labelcrop();
}
inline ::google::protobuf::int32 PrepCropParam::labelcrop() const {
  return labelcrop_;
}
inline void PrepCropParam::set_labelcrop(::google::protobuf::int32 value) {
  set_has_labelcrop();
  labelcrop_ = value;
}

// -------------------------------------------------------------------

// PrepBlurParam

// optional float mean = 1 [default = 0];
inline bool PrepBlurParam::has_mean() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrepBlurParam::set_has_mean() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrepBlurParam::clear_has_mean() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrepBlurParam::clear_mean() {
  mean_ = 0;
  clear_has_mean();
}
inline float PrepBlurParam::mean() const {
  return mean_;
}
inline void PrepBlurParam::set_mean(float value) {
  set_has_mean();
  mean_ = value;
}

// optional float std = 2 [default = 0.1];
inline bool PrepBlurParam::has_std() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrepBlurParam::set_has_std() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrepBlurParam::clear_has_std() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrepBlurParam::clear_std() {
  std_ = 0.1f;
  clear_has_std();
}
inline float PrepBlurParam::std() const {
  return std_;
}
inline void PrepBlurParam::set_std(float value) {
  set_has_std();
  std_ = value;
}

// optional int32 ksize = 3 [default = 5];
inline bool PrepBlurParam::has_ksize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrepBlurParam::set_has_ksize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrepBlurParam::clear_has_ksize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrepBlurParam::clear_ksize() {
  ksize_ = 5;
  clear_has_ksize();
}
inline ::google::protobuf::int32 PrepBlurParam::ksize() const {
  return ksize_;
}
inline void PrepBlurParam::set_ksize(::google::protobuf::int32 value) {
  set_has_ksize();
  ksize_ = value;
}

// -------------------------------------------------------------------

// PrepDeformParam

// optional float mean_x = 1 [default = 0];
inline bool PrepDeformParam::has_mean_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrepDeformParam::set_has_mean_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrepDeformParam::clear_has_mean_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrepDeformParam::clear_mean_x() {
  mean_x_ = 0;
  clear_has_mean_x();
}
inline float PrepDeformParam::mean_x() const {
  return mean_x_;
}
inline void PrepDeformParam::set_mean_x(float value) {
  set_has_mean_x();
  mean_x_ = value;
}

// optional float mean_y = 2 [default = 0];
inline bool PrepDeformParam::has_mean_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrepDeformParam::set_has_mean_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrepDeformParam::clear_has_mean_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrepDeformParam::clear_mean_y() {
  mean_y_ = 0;
  clear_has_mean_y();
}
inline float PrepDeformParam::mean_y() const {
  return mean_y_;
}
inline void PrepDeformParam::set_mean_y(float value) {
  set_has_mean_y();
  mean_y_ = value;
}

// optional float std_x = 3 [default = 0.1];
inline bool PrepDeformParam::has_std_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrepDeformParam::set_has_std_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrepDeformParam::clear_has_std_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrepDeformParam::clear_std_x() {
  std_x_ = 0.1f;
  clear_has_std_x();
}
inline float PrepDeformParam::std_x() const {
  return std_x_;
}
inline void PrepDeformParam::set_std_x(float value) {
  set_has_std_x();
  std_x_ = value;
}

// optional float std_y = 4 [default = 0.1];
inline bool PrepDeformParam::has_std_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrepDeformParam::set_has_std_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrepDeformParam::clear_has_std_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrepDeformParam::clear_std_y() {
  std_y_ = 0.1f;
  clear_has_std_y();
}
inline float PrepDeformParam::std_y() const {
  return std_y_;
}
inline void PrepDeformParam::set_std_y(float value) {
  set_has_std_y();
  std_y_ = value;
}

// -------------------------------------------------------------------

// PrepClaheParam

// optional float clip = 1 [default = 4];
inline bool PrepClaheParam::has_clip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrepClaheParam::set_has_clip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrepClaheParam::clear_has_clip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrepClaheParam::clear_clip() {
  clip_ = 4;
  clear_has_clip();
}
inline float PrepClaheParam::clip() const {
  return clip_;
}
inline void PrepClaheParam::set_clip(float value) {
  set_has_clip();
  clip_ = value;
}

// -------------------------------------------------------------------

// PrepHistEqParam

// optional bool patch_prior = 1 [default = true];
inline bool PrepHistEqParam::has_patch_prior() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrepHistEqParam::set_has_patch_prior() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrepHistEqParam::clear_has_patch_prior() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrepHistEqParam::clear_patch_prior() {
  patch_prior_ = true;
  clear_has_patch_prior();
}
inline bool PrepHistEqParam::patch_prior() const {
  return patch_prior_;
}
inline void PrepHistEqParam::set_patch_prior(bool value) {
  set_has_patch_prior();
  patch_prior_ = value;
}

// optional bool masking = 2 [default = false];
inline bool PrepHistEqParam::has_masking() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrepHistEqParam::set_has_masking() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrepHistEqParam::clear_has_masking() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrepHistEqParam::clear_masking() {
  masking_ = false;
  clear_has_masking();
}
inline bool PrepHistEqParam::masking() const {
  return masking_;
}
inline void PrepHistEqParam::set_masking(bool value) {
  set_has_masking();
  masking_ = value;
}

// repeated float label_boost = 3;
inline int PrepHistEqParam::label_boost_size() const {
  return label_boost_.size();
}
inline void PrepHistEqParam::clear_label_boost() {
  label_boost_.Clear();
}
inline float PrepHistEqParam::label_boost(int index) const {
  return label_boost_.Get(index);
}
inline void PrepHistEqParam::set_label_boost(int index, float value) {
  label_boost_.Set(index, value);
}
inline void PrepHistEqParam::add_label_boost(float value) {
  label_boost_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
PrepHistEqParam::label_boost() const {
  return label_boost_;
}
inline ::google::protobuf::RepeatedField< float >*
PrepHistEqParam::mutable_label_boost() {
  return &label_boost_;
}

// optional float border_boost = 4 [default = 1];
inline bool PrepHistEqParam::has_border_boost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrepHistEqParam::set_has_border_boost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrepHistEqParam::clear_has_border_boost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrepHistEqParam::clear_border_boost() {
  border_boost_ = 1;
  clear_has_border_boost();
}
inline float PrepHistEqParam::border_boost() const {
  return border_boost_;
}
inline void PrepHistEqParam::set_border_boost(float value) {
  set_has_border_boost();
  border_boost_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace caffe_neural

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_caffetool_2eproto__INCLUDED
